<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Londrina+Solid:wght@100;300;400;900&family=Manrope:wght@200..800&display=swap" rel="stylesheet">
  <script src="https://kit.fontawesome.com/cff1dcbb48.js" crossorigin="anonymous"></script>
  
  <title>Simple Cooking Game</title>
  <style>
    /* ë°°ê²½ìƒ‰ì„ #FEFCE7ë¡œ ë³€ê²½ */
    body {
      margin: 0;
      overflow: hidden;
      background-color: #FEFCE7;
      background-position: center;
      background-repeat: no-repeat;
    }

    #soundToggle {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 20;
      font-size: 30px;
      color: #5B3303; /* ì´ˆê¸°ê°’: ì¬ìƒ ì¤‘ ìƒ‰ìƒ */
      cursor: pointer;
    }
    
    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #5B3303;
      font-family: "Manrope", sans-serif;
      z-index: 10;
    }
    /* Cook ë²„íŠ¼: ë°ìŠ¤í¬íƒ‘ì—ì„œëŠ” ìš°ì¸¡ í•˜ë‹¨, ëª¨ë°”ì¼ì—ì„œëŠ” ì¤‘ì•™ í•˜ë‹¨ */
    #cookButton {
      position: absolute;
      bottom: 26px;
      background-color: #F8DCAD;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 36px;
      border-radius: 6px;
      border: solid 2px;
      z-index: 10;
      font-family: "Londrina Solid", sans-serif;
      font-weight: 800;
      font-style: normal;
      color: #5B3303;
      border-color: rgb(91, 51, 3);
      box-shadow: 2px 2px 7px 2px rgb(60 53 45 / 30%)
    }
    /* í˜¸ë²„ ë ˆì´ë¸” ìŠ¤íƒ€ì¼ */
    #hoverLabel {
      position: absolute;
      pointer-events: none;
      color: white;
      font-family: Manrope, sans-serif;
      font-size: 12px;
      display: none;
      background: rgba(0, 0, 0, 0.5);
      padding: 2px 4px;
      border-radius: 4px;
      z-index: 20;
    }
  </style>
</head>
<body>
  <audio id="bgm" src="assets/boba.mp3" autoplay loop muted></audio>
  <audio id="clickSound" src="assets/Click.mp3" preload="none"></audio>
  <div id="soundToggle">
    <i class="fa-solid fa-music"></i>
  </div>
  <!-- ì¢Œì¸¡ ìƒë‹¨ UI: ì¹´ìš´í„° ë° Heat ìƒíƒœ -->
  <div id="ui">
    <div>Noodle: <span id="noodleCount">0</span></div>
    <div>Onion: <span id="onionCount">0</span></div>
    <div>Spice: <span id="spiceCount">0</span></div>
    <div>Egg: <span id="eggCount">0</span></div>
    <div>Heat: <span id="heatState">OFF</span></div>
  </div>

  <!-- ë°°ê²½ ìŒì•… -->
  <script>
    const bgm = document.getElementById("bgm");
    const soundToggle = document.getElementById("soundToggle");
    bgm.volume = 0.2;
    // í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ ì¬ìƒ ì‹œë„
    window.addEventListener("load", () => {
      // 1. muted ìƒíƒœë¡œ play ì‹œë„
      bgm.muted = true;
      bgm.play().then(() => {
        console.log("Muted autoplay succeeded");
  
        // 2. 0.5ì´ˆ í›„ mute í•´ì œ (ë¸Œë¼ìš°ì €ê°€ í—ˆìš©í•  ê°€ëŠ¥ì„± ë†’ì•„ì§)
        setTimeout(() => {
          bgm.muted = false;
          soundToggle.style.color = "#5B3303";
        }, 10);
      }).catch((err) => {
        console.log("Autoplay failed. Interaction required:", err);
        soundToggle.style.color = "#ACAFA8"; // ì‹¤íŒ¨ ì‹œ íšŒìƒ‰ìœ¼ë¡œ ì„¤ì •
      });
    });
  
    // ìœ ì €ê°€ í´ë¦­í•´ì„œ ì§ì ‘ mute / unmute
    soundToggle.addEventListener("click", () => {
      playClickSound();
      bgm.muted = !bgm.muted;
      soundToggle.style.color = bgm.muted ? "#ACAFA8" : "#5B3303";
    });

    function playClickSound() {
  const clickSound = document.getElementById("clickSound");
  clickSound.currentTime = 0; // ë§¤ë²ˆ ì²˜ìŒë¶€í„° ì¬ìƒ
  clickSound.play().catch(e => console.log("Click sound play error:", e));
}
  </script>

  <!-- í•˜ë‹¨ ì¤‘ì•™ Cook ë²„íŠ¼ -->
  <button id="cookButton">COOK <i class="fa-sharp fa-solid fa-arrow-right"></i></button>

  <!-- ë§ˆìš°ìŠ¤ í˜¸ë²„ì‹œ í‘œì‹œë  ë ˆì´ë¸” -->
  <div id="hoverLabel"></div>

  <!-- Three.js ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- GLTFLoader (Three.js í™•ì¥ ë¼ì´ë¸ŒëŸ¬ë¦¬) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    // ì „ì—­ ë³€ìˆ˜ (ì¹´ìš´í„° ë° Heat ìƒíƒœ)
    let noodleCount = 0, onionCount = 0, spiceCount = 0, eggCount = 0;
    let heatStateIndex = 0;
    const heatStates = ["OFF", "LOW", "MID", "HIGH"];

    // Three.js ê¸°ë³¸ ë³€ìˆ˜ ë° ë“œë˜ê·¸ ê´€ë ¨ ë³€ìˆ˜
    let scene, camera, renderer;
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    let selectedObject = null;
    let offset = new THREE.Vector3();

let controlModel;            // ì›ë˜ ì½”ë“œë‘ ì¶©ëŒ ë°©ì§€ ìœ„í•´ ì´ë¦„ ë‚¨ê²¨ë‘˜ ìˆ˜ ìˆì–´
let controlLogicModel;       // ì§„ì§œ ë¡œì§ìš© (ìˆ¨ê¹€ ì²˜ë¦¬)
let controlVisibleModel;     // ì‚¬ìš©ìì—ê²Œ ë³´ì´ëŠ” ê°€ì§œ (MeshBasicMaterial)


    // ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ ë°°ì—´ (ì›ë³¸ì€ ì”¬ì— ë‚¨ì•„ ìˆìŒ)
    let draggableObjects = [];
    // ê³ ì •ëœ Heat ìŠ¤í”„ë¼ì´íŠ¸ (í´ë¦­ ë²„íŠ¼ìœ¼ë¡œ ì‚¬ìš©)
    let fixedHeatSprite;

    init();
    animate();

    // í—¬í¼ í•¨ìˆ˜: Raycasterê°€ ë°˜í™˜í•œ ê°ì²´ê°€ Meshì¼ ê²½ìš°, ìƒìœ„ì˜ draggable ê°ì²´ë¥¼ ì°¾ì•„ì¤ë‹ˆë‹¤.
    function getDraggableObject(object) {
      while (object && !object.userData.draggable) {
        object = object.parent;
      }
      return object;
    }
    function createBackgroundPlane(texture) {
  // ì´ë¯¸ì§€ ìì²´ì˜ ë¹„ìœ¨ ê°€ì ¸ì˜¤ê¸°
  const imageAspect = texture.image.width / texture.image.height;
  const screenAspect = window.innerWidth / window.innerHeight;

  let planeWidth, planeHeight;

  if (screenAspect < imageAspect) {
    // í™”ë©´ì´ ë” ì„¸ë¡œë¡œ ê¸¸ë©´ -> ë†’ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë§ì¶”ê³ , ë„ˆë¹„ëŠ” ë¹„ìœ¨ë¡œ ê³„ì‚°
    planeHeight = 12;
    planeWidth = planeHeight * imageAspect;
  } else {
    // í™”ë©´ì´ ë” ê°€ë¡œë¡œ ê¸¸ë©´ -> ë„ˆë¹„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë§ì¶”ê³ , ë†’ì´ëŠ” ë¹„ìœ¨ë¡œ ê³„ì‚°
    planeWidth = 12 * screenAspect;
    planeHeight = planeWidth / imageAspect;
  }

  const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
  const material = new THREE.MeshBasicMaterial({ map: texture });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.z = -1;
  scene.add(mesh);
}

const loader = new THREE.TextureLoader();
loader.load("assets/bg-test.jpg", (texture) => {
  createBackgroundPlane(texture);
});

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 12);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.shadowMap.enabled = true; // ê·¸ë¦¼ì í™œì„±í™”
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xFEFCE7, 1); // ë°°ê²½ìƒ‰ ì„¤ì •
      document.body.appendChild(renderer.domElement);

      
      // ì˜ˆ: ê°•ë„ë¥¼ 0.3ìœ¼ë¡œ ì¤„ì„
      const ambientLight = new THREE.AmbientLight(0xfdfdfd, 0);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xfdfdfd, 0.5);
      directionalLight.position.set(-10, 5, 10); // ì™¼ìª½, ìœ„, ì•ìª½ì—ì„œ ë¹›ì´ ì˜µë‹ˆë‹¤.
      directionalLight.castShadow = true; // ê·¸ë¦¼ì íš¨ê³¼ë„ ì ìš© ê°€ëŠ¥
      scene.add(directionalLight);



      // ì¤‘ì•™ Pot (ê³ ì •)
      const pot = createTextSprite("Pot", { fontsize: 40 });
      pot.position.set(0, 0, 0);
      scene.add(pot);

      // ê³ ì • Heat ìŠ¤í”„ë¼ì´íŠ¸ (í´ë¦­ ì‹œ ìƒ‰ìƒ ë³€ê²½, pot ì•„ë˜ìª½)
      fixedHeatSprite = createTextSprite("Heat", { fontsize: 22 });
      fixedHeatSprite.position.set(0, -1.5, 0);
      scene.add(fixedHeatSprite);
      updateFixedHeatSprite(); // ì´ˆê¸° ìƒíƒœ ë°˜ì˜

      // ìŠ¤í”Œë¼ì¸ì—ì„œ ë‚´ë³´ë‚¸ ì—ì…‹(GLB íŒŒì¼)ìœ¼ë¡œ ì¬ë£Œë“¤ì„ ë¡œë“œ (ìœ„ì¹˜: pot ìœ„ìª½ í•œ ì¤„)
   
      
      // ë°°ì¹˜ ë²”ìœ„ì™€ ìµœì†Œ ê°„ê²© ì„¤ì • (í•„ìš”ì— ë”°ë¼ ì¡°ì ˆ)
      const ingredients = [
        { type: "Noodle", url: "assets/noodle.glb" },
        { type: "Onion",  url: "assets/onion.glb" },
        { type: "Spice",  url: "assets/spice.glb" },
        { type: "Egg",    url: "assets/egg.glb" }
      ];
      
      // ë°°ì¹˜ ë²”ìœ„ ì„¤ì • (í•„ìš”ì— ë”°ë¼ ì¡°ì ˆ)
      const minX = -1.2, maxX = 1.3, minY = 0, maxY = 3;
      
      // ì´ë¯¸ ë°°ì¹˜ëœ ëª¨ë¸ ì •ë³´ë¥¼ ì €ì¥í•˜ëŠ” ë°°ì—´ (ìœ„ì¹˜ì™€ approximate ë°˜ì§€ë¦„)
      const placedModels = [];

      // ê²¹ì¹˜ì§€ ì•ŠëŠ” ìœ„ì¹˜ë¥¼ ìƒì„±í•˜ëŠ” í•¨ìˆ˜ (bounding box ë°˜ì§€ë¦„ ê¸°ë°˜)
      function generateNonOverlappingPosition(existingModels, minX, maxX, minY, maxY, newRadius) {
        let pos;
        let attempts = 0;
        do {
          pos = new THREE.Vector3(
            Math.random() * (maxX - minX) + minX,
            Math.random() * (maxY - minY) + minY,
            0
          );
          attempts++;
          // ë§Œì•½ 100íšŒ ì´ìƒ ì‹œë„í–ˆìŒì—ë„ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ëª»í•˜ë©´ break
          if (attempts > 100) break;
        } while(existingModels.some(existing => pos.distanceTo(existing.pos) < (existing.radius + newRadius)));
        return pos;
      }

      // GLTFLoaderë¥¼ ì‚¬ìš©í•´ ì¬ë£Œ ëª¨ë¸ ë¡œë“œ ë° ë°°ì¹˜
      function loadIngredientModel(item) {
        const loader = new THREE.GLTFLoader();
        loader.load(item.url, function(gltf) {
          const model = gltf.scene;

          // ëª¨ë¸ì˜ bounding boxë¥¼ ê³„ì‚°í•˜ì—¬ approximate ë°˜ì§€ë¦„ì„ êµ¬í•¨
          const bbox = new THREE.Box3().setFromObject(model);
          const size = new THREE.Vector3();
          bbox.getSize(size);
          const radius = size.length() / 2; // ëŒ€ëµì ì¸ í¬ê¸°
          
          // bounding box ë°˜ì§€ë¦„ì„ ê³ ë ¤í•´ ê²¹ì¹˜ì§€ ì•ŠëŠ” ìœ„ì¹˜ ìƒì„±
          const pos = generateNonOverlappingPosition(placedModels, minX, maxX, minY, maxY, radius);
          // ìƒì„±ëœ ìœ„ì¹˜ì™€ ë°˜ì§€ë¦„ ì •ë³´ë¥¼ ë°°ì—´ì— ì €ì¥
          placedModels.push({ pos: pos, radius: radius });
          
          model.position.copy(pos);
          model.userData = { type: item.type, draggable: true };
          scene.add(model);
          draggableObjects.push(model);
        }, undefined, function(error) {
          console.error("Error loading model:", error);
        });
      }

      // ê° ì¬ë£Œë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.
      ingredients.forEach((item) => {
        loadIngredientModel(item);
      });

      // burner.glb asset loading
      function loadBurnerModel() {
        const loader = new THREE.GLTFLoader();
        loader.load("assets/burner.glb", function(gltf) {
          const model = gltf.scene;

          // í¬ê¸° ì¡°ì ˆ: ê°€ë¡œ í™”ë©´ ë¹„ìœ¨ì— ë§ì¶”ì–´ width ê¸°ì¤€ìœ¼ë¡œ ìŠ¤ì¼€ì¼ë§
          const desiredWidth = 12; // í™”ë©´ í­ ê¸°ì¤€
          const bbox = new THREE.Box3().setFromObject(model);
          const size = new THREE.Vector3();
          bbox.getSize(size);
          const scale = desiredWidth / size.x;
          model.scale.setScalar(scale);

          // ìœ„ì¹˜ ì¡°ì ˆ: í™”ë©´ì˜ í•˜ë‹¨ 1/3 ë†’ì´, zëŠ” ë’¤ë¡œ ì„¤ì • (ì˜ˆ: -2)
          model.position.set(-0.05, -3.6, 3); // y ê°’ì€ í™”ë©´ ë¹„ìœ¨ì— ë”°ë¼ ì¡°ì ˆ ê°€ëŠ¥
          model.scale.set(0.95, 1, 0.95);

          burnerModel = model;

          // íŠ¹ì • ìƒ‰ìƒì„ ê°€ì§„ Meshì— íƒœê·¸ ì§€ì •
          model.traverse((child) => {
            if (child.isMesh) {
              const hexColor = child.material.color.getHexString().toUpperCase();
              if (hexColor === '9D0F0F') {
                child.userData.isBurnerHeat = true;
              }
            }
          });

          scene.add(model);
          
          model.traverse((child) => {
      if (child.isMesh && child.userData.isBurnerHeat) {
        child.visible = (heatStates[heatStateIndex] !== "OFF");
      }
    });

        }, undefined, function(error) {
          console.error("Error loading burner model:", error);
        });
      }
      
      //control.glb asset loading
      function loadControlModel() {
        const loader = new THREE.GLTFLoader();
        loader.load("assets/control.glb", function (gltf) {
          const model = gltf.scene;

          // í¬ê¸° ì¡°ì ˆ: burnerì™€ ë¹„ìŠ·í•œ í­ ê¸°ì¤€ìœ¼ë¡œ ì¡°ì •
          const desiredWidth = 12; // ê°™ì€ ê¸°ì¤€ ì‚¬ìš©
          const bbox = new THREE.Box3().setFromObject(model);
          const size = new THREE.Vector3();
          bbox.getSize(size);
          const scale = desiredWidth / size.x;
          model.scale.setScalar(scale);

          // ìœ„ì¹˜ ì¡°ì ˆ: yëŠ” burnerì™€ ë™ì¼ (-4.2), zëŠ” burnerë³´ë‹¤ ì• (ì˜ˆ: -1.5)
          model.position.set(0, -1.6, 3);
          model.scale.set(1.5, 1.5, 1.5);

          // ëª¨ë¸ ì €ì¥
          controlModel = model;

          // í´ë¦­ ì´ë²¤íŠ¸ë¥¼ ìœ„í•œ userData ì¶”ê°€
          controlModel.userData = { isControl: true };
          

          scene.add(controlModel);

          
          }, undefined, function (error) {
          console.error("Error loading control model:", error);
          });

          
      }

      loadBurnerModel();
      loadControlModel();

      // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
      renderer.domElement.addEventListener('mousedown', onMouseDown, false);
      renderer.domElement.addEventListener('mousemove', onMouseMove, false);
      renderer.domElement.addEventListener('mouseup', onMouseUp, false);
      window.addEventListener('resize', onWindowResize, false);
      document.getElementById("cookButton").addEventListener("click", () => {
        playClickSound(); // ğŸ”Š ì‚¬ìš´ë“œ ë¨¼ì €
        onCook(); // ğŸ³ ìš”ë¦¬ íŒì • ì‹¤í–‰
      });
    }

    // UI ì—…ë°ì´íŠ¸: ì¢Œì¸¡ UI ì¹´ìš´í„°ì™€ Heat í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
    function updateUI() {
      document.getElementById("noodleCount").textContent = noodleCount;
      document.getElementById("onionCount").textContent = onionCount;
      document.getElementById("spiceCount").textContent = spiceCount;
      document.getElementById("eggCount").textContent = eggCount;
      document.getElementById("heatState").textContent = heatStates[heatStateIndex];
      playClickSound();
    }
    fixedHeatSprite.visible = false;

    // ê³ ì • Heat ìŠ¤í”„ë¼ì´íŠ¸ì˜ í…ìŠ¤ì²˜ë¥¼ ìƒíƒœì— ë”°ë¼ (OFF/LOW/MID/HIGH) ìƒ‰ìƒ ë³€ê²½
    function updateFixedHeatSprite() {
      let bgColor;
      switch (heatStates[heatStateIndex]) {
        case "LOW":  bgColor = "yellow"; break;
        case "MID":  bgColor = "orange"; break;
        case "HIGH": bgColor = "red";    break;
        default:     bgColor = "white";  break; // OFF
      }

      let fontsize = 20, fontface = "Arial", borderThickness = 2;
      let canvas = document.createElement('canvas');
      let context = canvas.getContext('2d');
      context.font = fontsize + "px " + fontface;

      let metrics = context.measureText("Heat");
      let textWidth = metrics.width;
      canvas.width = textWidth + borderThickness * 4;
      canvas.height = fontsize * 1.4 + borderThickness * 4;

      // ë°°ê²½ìƒ‰ ì ìš©
      context.fillStyle = bgColor;
      context.fillRect(0, 0, canvas.width, canvas.height);

      // í…Œë‘ë¦¬
      context.strokeStyle = "rgba(0,0,0,1.0)";
      context.lineWidth = borderThickness;
      context.strokeRect(0, 0, canvas.width, canvas.height);

      // í…ìŠ¤íŠ¸
      context.fillStyle = "black";
      context.textAlign = "center";
      context.textBaseline = "middle";
      context.font = fontsize + "px " + fontface;
      context.fillText("Heat", canvas.width / 2, canvas.height / 2);

      let texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
      fixedHeatSprite.material.map = texture;
    }

    // GLTFLoaderë¥¼ ì‚¬ìš©í•´ ìŠ¤í”Œë¼ì¸ ì—ì…‹(GLB íŒŒì¼) ë¡œë“œ
    function loadIngredientModel(item, position) {
      const loader = new THREE.GLTFLoader();
      loader.load(item.url, function(gltf) {
        const model = gltf.scene;
        model.position.copy(position);
        // ë“œë˜ê·¸ ë° ì¸í„°ë™ì…˜ì„ ìœ„í•´ ì‚¬ìš©ì ë°ì´í„° ì¶”ê°€
        model.userData = { type: item.type, draggable: true };
        scene.add(model);
        draggableObjects.push(model);
      }, undefined, function(error) {
        console.error("Error loading model:", error);
      });
    }

    function onMouseDown(event) {
      event.preventDefault();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      // ê³ ì • Heat ìŠ¤í”„ë¼ì´íŠ¸ í´ë¦­ ì²´í¬
      let heatIntersects = raycaster.intersectObject(fixedHeatSprite);
      if (heatIntersects.length > 0) {
        heatStateIndex = (heatStateIndex + 1) % heatStates.length;
        updateUI();
        return;
      }

      

      // ğŸ”¥ controlModel í´ë¦­ ì²´í¬
      if (controlModel) {
  const intersects = raycaster.intersectObject(controlModel, true);
  if (intersects.length > 0) {
    heatStateIndex = (heatStateIndex + 1) % heatStates.length;

    const angles = [0, -45, -90, -155];
    const rad = THREE.MathUtils.degToRad(angles[heatStateIndex]);
    controlModel.rotation.z = rad;

    updateUI(); // ì™¼ìª½ UI ê°±ì‹ 

    // ğŸ”¥ ì—¬ê¸°ì„œ ìƒ‰ìƒë„ ì—…ë°ì´íŠ¸ í•´ì¤˜ì•¼ í•¨!
    if (burnerModel) {
      const stateColorMap = {
        "LOW": 0xFFB300,
        "MID": 0xFF6600,
        "HIGH": 0xFF3C00
      };

      burnerModel.traverse((child) => {
        if (child.isMesh && child.userData.isBurnerHeat) {
          if (heatStates[heatStateIndex] === "OFF") {
            child.visible = false;
          } else {
            child.visible = true;
            child.material = child.material.clone(); // ê¼­ ë³µì œ!
            child.material.color.setHex(stateColorMap[heatStates[heatStateIndex]]);
          }
        }
      });
    }

    return; // ğŸ’¥ ì´ return ìœ„ì—ì„œ ëª¨ë“  ë™ì‘ì„ ë§ˆì³ì•¼ í•¨!
  }
}

      
      if (burnerModel) {
        const stateColorMap = {
          "LOW": 0xFFB300,   // ë…¸ë‘
          "MID": 0xFF6600,   // ì£¼í™©
          "HIGH": 0xFF3C00   // ì›ë˜ ìƒ‰ìƒìœ¼ë¡œ ë³µêµ¬
        };

        burnerModel.traverse((child) => {
          if (child.isMesh && child.userData.isBurnerHeat) {
            if (heatStates[heatStateIndex] === "OFF") {
              child.visible = false;
            } else {
              child.visible = true;
              child.material = child.material.clone(); // ì¬ì§ˆ ë³µì œ
              child.material.color.setHex(stateColorMap[heatStates[heatStateIndex]]);
            }
          }
        });
      }

      
      // draggableObjectsì˜ ëª¨ë“  ìì‹ê¹Œì§€ í¬í•¨í•´ì„œ ì¸í„°ì„¹ì…˜ ê³„ì‚°
      let intersects = raycaster.intersectObjects(draggableObjects, true);
      if (intersects.length > 0) {
        // í´ë¦­ëœ ê°ì²´ì˜ ìƒìœ„ draggable ê°ì²´ ì°¾ê¸°
        let original = getDraggableObject(intersects[0].object);
        if (!original) return;
        // ì „ì²´ ë³µì œ (deep clone)
        selectedObject = original.clone(true);
        selectedObject.userData = original.userData;
        selectedObject.position.copy(original.position);
        scene.add(selectedObject);

        let intersection = new THREE.Vector3();
        raycaster.ray.intersectPlane(dragPlane, intersection);
        offset.copy(selectedObject.position).sub(intersection);
      }
    }

    function onMouseMove(event) {
      event.preventDefault();
      if (selectedObject) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        let intersection = new THREE.Vector3();
        if (raycaster.ray.intersectPlane(dragPlane, intersection)) {
          selectedObject.position.copy(intersection.add(offset));
        }
      } else {
        // ë“œë˜ê·¸ ì¤‘ì´ ì•„ë‹ ë•Œ, í˜¸ë²„ ë ˆì´ë¸” í‘œì‹œ
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        let intersects = raycaster.intersectObjects(draggableObjects, true);
        const hoverLabel = document.getElementById("hoverLabel");
        if (intersects.length > 0) {
          let hoveredObj = getDraggableObject(intersects[0].object);
          if (hoveredObj) {
            hoverLabel.textContent = hoveredObj.userData.type;
            hoverLabel.style.left = (event.clientX + 10) + "px";
            hoverLabel.style.top = (event.clientY + 10) + "px";
            hoverLabel.style.display = "block";
          }
        } else {
          hoverLabel.style.display = "none";
        }
      }
    }

    function onMouseUp(event) {
      event.preventDefault();
      if (selectedObject) {
        // Pot(0,0,0) ê·¼ì²˜ë¡œ ë“œë¡­ ì‹œ ì¹´ìš´í„° ì¦ê°€
        let distance = selectedObject.position.distanceTo(new THREE.Vector3(0, 0, 0));
        if (distance < 1) {
          let type = selectedObject.userData.type;
          if (type === "Noodle") noodleCount++;
          else if (type === "Onion") onionCount++;
          else if (type === "Spice") spiceCount++;
          else if (type === "Egg") eggCount++;
          updateUI();
        }
        // ë³µì œë³¸ ì œê±°
        scene.remove(selectedObject);
        selectedObject = null;
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    // COOK ë²„íŠ¼ í´ë¦­ ì‹œ ê²°ê³¼ íŒë‹¨
    function onCook() {
      // Noodle, Onion, Spiceì˜ ì¹´ìš´í„°ê°€ ë™ì¼í•˜ë©° Heatê°€ LOW ë˜ëŠ” MIDì´ë©´ Good
      if (noodleCount === onionCount && onionCount === spiceCount &&
          (heatStates[heatStateIndex] === "LOW" || heatStates[heatStateIndex] === "MID")) {
        showResult("Good Balancing!");
      } else {
        showResult("Fail... Balancing flavour is important!");
      }
    }

    // ê²°ê³¼ í˜ì´ì§€ í‘œì‹œ (ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ ë²„íŠ¼ í¬í•¨)
    function showResult(result) {
      if (result === "Fail... Balancing flavour is important!") {
        document.body.innerHTML = `
          <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100vh; font-size:48px; color:white; background: #FEFCE7;">
            <div>${result}</div>
            <button onclick="window.location.reload()" style="margin-top:20px; padding:10px 20px; font-size:24px;">Try Again</button>
          </div>
        `;
      } else {
        document.body.innerHTML = `
          <div style="display:flex; align-items:center; justify-content:center; height:100vh; font-size:48px; color:white; background: #FEFCE7;">
            ${result}
          </div>
        `;
      }
    }

    // í…ìŠ¤íŠ¸ ìŠ¤í”„ë¼ì´íŠ¸ ìƒì„± í•¨ìˆ˜ (canvas ê¸°ë°˜)
    function createTextSprite(message, parameters) {
      if (parameters === undefined) parameters = {};
      let fontface = parameters.fontface || "Arial";
      let fontsize = parameters.fontsize || 24;
      let borderThickness = parameters.borderThickness !== undefined ? parameters.borderThickness : 2;
      let borderColor = parameters.borderColor || { r:0, g:0, b:0, a:1.0 };
      let backgroundColor = parameters.backgroundColor || { r:255, g:255, b:255, a:1.0 };

      let canvas = document.createElement('canvas');
      let context = canvas.getContext('2d');
      context.font = fontsize + "px " + fontface;

      // í…ìŠ¤íŠ¸ í¬ê¸° ì¸¡ì •
      let metrics = context.measureText(message);
      let textWidth = metrics.width;
      canvas.width = textWidth + borderThickness * 4;
      canvas.height = fontsize * 1.4 + borderThickness * 4;

      // ë°°ê²½ìƒ‰ ë° í…Œë‘ë¦¬ ì„¤ì •
      context.fillStyle = `rgba(${backgroundColor.r},${backgroundColor.g},${backgroundColor.b},${backgroundColor.a})`;
      context.fillRect(0, 0, canvas.width, canvas.height);
      context.strokeStyle = `rgba(${borderColor.r},${borderColor.g},${borderColor.b},${borderColor.a})`;
      context.lineWidth = borderThickness;
      context.strokeRect(0, 0, canvas.width, canvas.height);

      // í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
      context.fillStyle = "black";
      context.textAlign = "center";
      context.textBaseline = "middle";
      context.font = fontsize + "px " + fontface;
      context.fillText(message, canvas.width / 2, canvas.height / 2);

      let texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
      let spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
      let sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(canvas.width / 100, canvas.height / 100, 1);
      return sprite;
    }
  </script>
</body>
</html>
